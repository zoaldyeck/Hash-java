import java.util.ArrayList;

//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
    
    //
    // Create an empty table big enough to hold maxSize records.
    //
	public static Record[] table;
	public static int n=0;    //count the number of inserted items
	
    public StringTable(int maxSize) 
    {
    	table=new Record[2];   //initialize the size to be 2
    	}    
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
   
    public boolean insert(Record r) 
    { 
		int m=table.length;
    	if(n<m/4){           //if the load factor is smaller than 1/4,we insert the new
    		int hashKey=toHashKey(r.key);
    		int base=baseHash(hashKey);
    		int step=stepHash(hashKey);
    		int k=base%m;       //calculate the s0(k),s1(k)...
    		r.hashKey=hashKey;  //store the tohashKey(r.key) in hashKey
    		for(int i=0;i<m;i++){
    			if(table[k]==null){  //if it's null,insert,n++,return ture //TA: You should also be inserting over deleted slots (-7 for not reusing deleted slots)
    				table[k]=r;	
    				n++;
    				return true;
    				}
    			else{
    				base=base+step; //if it's not null,look for the next place
    				k=base%m;
    			}		
    		}	
    	}
    	else{
    		Record[] old=new Record[m];  //if the load factor is bigger than 1/4,create a new table
    		System.out.println(m);
    		int j=0;
    		for(int i=0;i<m;i++)
    			if(table[i]!=null){   //copy all the old table's items to another array 
    				
    				old[j]=table[i];
    				j++;
    				table[i]=null;
    				}
    		table=new Record[2*m]; //construct a new table with double size
    		n=0;
    		for(int i=0;i<m;i++)
    			if(old[i]!=null)
    				//TA: should not copy over deleted elements, this is a waste of processing time/memory (-5)
    			insert(old[i]);	//insert the old items to the new table
    		insert(r);    //insert r
    		return true;  
    		}	
    	return true; 
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	if (find(r.key)!=null){   //if we find it, reset it to be "deleted", and n--
    		n--;
    		r.key=new String("deleted");
    	}   
    	}	
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int hashKey=toHashKey(key);
    	int base=baseHash(hashKey);
    	int step=stepHash(hashKey);
    	int m=table.length;
    	int k=base%m;          //calculate the s0(k),s1(k)...
    	for(int i=0;i<m;i++){
    		if(table[k]!=null){  //if it's not null(deleted or something else, or something right
    			if(!(table[k].key.equals("deleted"))&&table[k].hashKey==hashKey)
    			{
    				if((table[k].key).equals(key)) //if it's not "deleted" and the hashkey is right
    					return table[k];//compare the 2 strings to see if it's right string
    			}
    			else{ //if it's "deleted",or the hashkey is not right,we don't need to compare the strings
    			base=base+step;//we look for the next place to find the string
    			k=base%m;
    			}	
    		}
    		else  //if it's null, return null,fail
    			return null;
    	}
    	return null;//if we look for m times, fail
    }
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;//generate a integer v of the string s related 
		//to every char value and its position in the string
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
	// Fill in your own hash function here
    	int m=table.length;
    	double A=(Math.sqrt(5)-1)/2;//use v(from tohashkey(string s)) to calculate baseHash 
    	int base=(int) Math.floor(m*(hashKey*A-Math.floor(hashKey*A)));
    	return base;
    }
    
    int stepHash(int hashKey)
    {
	// Fill in your own hash function here
    	int m=table.length;
    	double A=Math.sqrt(2)/2;//use v(from tohashkey(string s)) to calculate stepHash 
    	int step=(int) Math.floor(m*(hashKey*A-Math.floor(hashKey*A)));
    	if(step%2==0)//the m is a power of 2,so stephash needs to be odd.
    		step++;
    	return step;
    }
}
